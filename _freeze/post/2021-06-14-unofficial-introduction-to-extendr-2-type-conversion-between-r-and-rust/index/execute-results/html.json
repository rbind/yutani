{
  "hash": "269ee4d07240d1a0d31f9226821b2eef",
  "result": {
    "markdown": "---\ntitle: \"Unofficial Introduction To extendr (2): Type Conversion Between R and Rust\"\ndescription: |\n  Integrate R and Rust with extendr\nauthor: Hiroaki Yutani\ndate: \"2021-06-14\"\ncategories: [Rust, extendr]\nformat:\n  html:\n    toc: true\n    toc-title: \"Contents\"\n    toc-location: left\n---\n\n\n\n\n[extendr](https://github.com/extendr/extendr) is a project that provides an interface between R and Rust. In [the last post](../2021-06-06-unofficial-introduction-to-extendr-1-your-first-r-package-with-rust/), I explained about how to create an R package with extendr briefly. This time, we'll walk though how to handle various R types.\n\n## Vector\n\nLet's start with the last example in the last post.\n\n\n::: {.cell}\n\n```{.rust .cell-code}\n#[extendr]\nfn add(x: i32, y: i32) -> i32 {\n    x + y\n}\n```\n:::\n\n\nWhile this works perfectly fine with a single value, this fails when the length is more than one.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadd(1:2, 2:3)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in add(1:2, 2:3): Input must be of length 1. Vector of length >1 given.\n```\n:::\n:::\n\n\nThis is very easy to fix. In Rust, we can use [`Vec<T>`](https://doc.rust-lang.org/std/vec/struct.Vec.html) to represent a vector of values of type `T`.\n\n\n::: {.cell}\n\n```{.rust .cell-code}\n// I don't explain much about the Rust code this time, but, for now, please don't\n// worry if you can't understand what it does at the moment. Probably it's not\n// very important to understand this post. Move forward.\n\n#[extendr]\nfn add2(x: Vec<i32>, y: Vec<i32>) -> Vec<i32> {\n    x.iter().enumerate().map(|(i, x)| x + y[i]).collect()\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nadd2(1:2, 2:3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3 5\n```\n:::\n:::\n\n\nEasy!\n\n### Wait, didn't you say we can't do this...!?\n\nSome of you might remember, in [this post](https://yutani.rbind.io/post/some-more-notes-about-using-rust-code-in-r-packages/#passing-a-vector-from-rust-to-r-or-vice-versa), I wrote\n\n> We cannot simply pass a variable length of vector\n\nfrom R to Rust.\n\nYeah, it's true it was too difficult because I was struggling to do it *via FFI*! There's no metadata available about the length or the structure of the data by default. But, with extendr, we can seamlessly access these metadata *via R's C API*. So, in short, extendr is the game changer.\n\n### `&[T]`\n\nIf you are already familiar with Rust, you might feel using `Vec<T>` as arguments looks a bit weird. In fact, the document of `Vec<T>` says:\n\n> In Rust, it's more common to pass slices as arguments rather than vectors when you just want to provide read access. The same goes for `String` and `&str`.\\\n> (<https://doc.rust-lang.org/std/vec/struct.Vec.html#slicing>)\n\nYes, you can use `&[T]` instead of `Vec<T>`, and this seems to matter on the performance slightly. If you are familiar with Rust to the extent that you know the difference between `&[T]` and `Vec<T>` (confession: I'm not!), you can should use `&[T]` instead. Otherwise, `Vec<T>` just works.\n\n\n::: {.cell}\n\n```{.rust .cell-code}\n#[extendr]\nfn add2_slice(x: &[i32], y: &[i32]) -> Vec<i32> {\n    x.iter().enumerate().map(|(i, x)| x + y[i]).collect()\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nadd2_slice(1:2, 2:3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3 5\n```\n:::\n:::\n\n\nPlease note that this isn't the reference to the original R object, just that to the copied values. If you really want no copying, you should use the \"proxy\" types, which I'll cover in the next post.\n\n## `NA`\n\nOne more caveat about `add()` is that this cannot handle a missing value, `NA`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadd(1L, NA)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in add(1L, NA): unable to convert R object to primitive\n```\n:::\n:::\n\n\nIn Rust, we can use [`Option<T>`](https://doc.rust-lang.org/std/option/enum.Option.html) to represent an optional, or possibly missing, value.\n\n\n::: {.cell}\n\n```{.rust .cell-code}\n// pattern match is one of the most powerful things in Rust, btw!\n\n#[extendr]\nfn add3(x: Option<i32>, y: Option<i32>) -> Option<i32> {\n    match (x, y) {\n        (Some(x), Some(y)) => Some(x + y),\n        _ => NA_INTEGER\n    }\n}\n```\n:::\n\n\nThis function can handle `NA`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadd3(1L, 2L)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n\n```{.r .cell-code}\nadd3(1L, NA)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA\n```\n:::\n:::\n\n\nIt might be safe to always use `Option` since there's always possibility that R value can be `NA` by nature. But, we might want to choose non-`Option` version to avoid the overhead (c.f. [How much overhead is there with Options and Results? - The Rust Programming Language Forum](https://users.rust-lang.org/t/how-much-overhead-is-there-with-options-and-results/37327)), so it depends.\n\n## Primitive types\n\nOkay, let's learn about the primitive types at last. Here's the corresponding table of R types and Rust types. We don't have the direct equivalent of `factor` and `complex` here, but let's talk about it later.\n\n| R           | Rust            |\n|-------------|-----------------|\n| `integer`   | `i32`           |\n| `numeric`   | `f64`           |\n| `logical`   | `bool`          |\n| `character` | `String` `&str` |\n| `factor`    | \\-              |\n| `complex`   | \\-              |\n\n### `integer` and `numeric`\n\n`integer` and `numeric` can mainly be converted into `i32` and `f64` respectively. I used \"mainly\" because it's not that strict. They both can be converted into either of:\n\n-   `u8`\n-   `u16`\n-   `u32`\n-   `u64`\n-   `i8`\n-   `i16`\n-   `i32`\n-   `i64`\n-   `f32`\n-   `f64`\n\nSo, in other words, if you don't want to prevent from numeric values are coerced into integers, you'll need to check the types by yourself.\n\n### `logical`\n\n`logical` is translated from/into `bool`. That's all.\n\n### `character`\n\n`character` is a bit tricky in that you can convert it to either of `String` and `&str`. You'll probably have to scratch your head to understand the concept of \"lifetime\" to choose the proper one (confession: I still don't understand it). But, in short,\n\n-   `String` : choose this when you modify the content strings\n\n-   `&str`: choose this (probably with `'static` lifetime) when you only reference the strings\n\nIf you are not familiar with Rust yet, I recommend you to start with `String`. `String` is copied around so you might have unnecessary overhead, but it's generally easier to handle because we need to think about the lifetimes less frequently.\n\n### `factor`\n\nTo put things simpler, until this point, I deliberately chose the cases when we have the corresponding types in Rust's side. But, `factor` isn't the case. It cannot be directly converted into a simple Rust type (at least at the moment). Instead, it can be cast into [`StrItr`](https://extendr.github.io/extendr/extendr_api/iter/struct.StrIter.html). `StrItr` is a \"proxy\" to the underlying data on R's side.\n\nI'll try explaining this in another post, but keep in mind that extendr provides that \"proxy\"-type of interface as well as the simple conversion to Rust's primitive types.\n\n## `list`\n\nThe corresponding Rust class for `list` is `List`. A `List` can be converted \ninto [`HashMap<&str, Robj>`](https://doc.rust-lang.org/std/collections/struct.HashMap.html).\nBe careful that R's `list` can be a different data structure than `Hashmap`; it \ncan have duplicated elements and unnamed elements.\n\n\n::: {.cell}\n\n```{.rust .cell-code}\nuse std::collections::HashMap;\n\n#[extendr]\nfn print_a(x: List) {\n    let x_hashmap: HashMap<&str, Robj> = x.into_hashmap();\n    \n    println!(\"{:?}\", x_hashmap.get(\"a\"));\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nprint_a(list(a = 1, b = 2))\nprint_a(list(b = 2))\n```\n:::\n\n\n[`r!`](https://extendr.github.io/extendr/extendr_api/macro.r.html) is a macro to create an R object from a Rust expression, by the way.\n\n## `Robj`?\n\nAs a sneak peak of the next post, let's take a look at the usage of `Robj`.\n\nSo far, I created only functions that accepts just one type. What if we want to create a function that accepts multiple types of arguments? In this case, we can create a function that takes `Robj` as its argument and convert it by ourselves. `Robj` has many methods `as_XXX()` to convert to (or, more precisely, extract and copy the value of R object, and turn it into) a type. Here, let's use `as_integer()` to generate `Option<i32>` .\n\n\n::: {.cell}\n\n```{.rust .cell-code}\n#[extendr]\nfn int(x: Robj) -> Option<i32> {\n    x.as_integer()\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# integer\nint(1L)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n\n```{.r .cell-code}\n# not integer-ish\nint(\"foo\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA\n```\n:::\n:::\n\n\n## What's next?\n\nIn this post, I focused mainly the Rust's side of the type ecosystem. Next, I probably need to write about more R-ish things like [`Function`](https://extendr.github.io/extendr/extendr_api/wrapper/function/struct.Function.html) or [`Symbol`](https://extendr.github.io/extendr/extendr_api/wrapper/symbol/struct.Symbol.html) , which I need some time to understand correctly. Stay tuned...\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}