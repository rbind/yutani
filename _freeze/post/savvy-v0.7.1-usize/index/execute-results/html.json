{
  "hash": "c61b311de12caec5c6a629991a7e02dd",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"What Is The Maximum Integer(-ish) Number That R Can Safely Handle?\"\nauthor: Hiroaki Yutani\ndate: '2024-10-21'\ncategories:\n  - Rust\n  - savvy\nimage: ./images/IEEE_754_Double_Floating_Point_Format.svg.png\n---\n\n\n\n\nRecently, I released a new version of [savvy](https://github.com/yutannihilation/savvy), a simple R extension interface using Rust, with improvement about a conversion to `usize`.\nI found some trickiness during implementing it, so I write a blog post.\n\n## `.Machine$integer.max`?\n\nAs you know, R's integer is 32-bit. A 32-bit singed integer can represent up to `2^31 - 1` (31-bit, becuase 1-bit is for the sign).\nIf the number exceeds the range, `NA_integer_` is returned.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- .Machine$integer.max\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2147483647\n```\n\n\n:::\n\n```{.r .cell-code}\nx + 1L\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in x + 1L: NAs produced by integer overflow\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n:::\n\n\n\n\nBut, you still can play with such a large number by treating it as numeric.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# adding a numeric makes the result numeric\nx + 1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2147483648\n```\n\n\n:::\n:::\n\n\n\n\nSo, apparently, `.Machine$integer.max` is not the limit. A numeric can represent integer numbers to some extent.\nBut, to what extent exactly? That's the question.\n\n## Double-precision floating-point\n\nIn order to know the answer, we need to look at how a numeric is represented in memory.\nR's numeric is a double-precision floating-point, which follows [the IEEE 754 standard](https://en.wikipedia.org/wiki/Double-precision_floating-point_format).\nThe format is like this:\n\n![IEEE 754 Double Floating Point Format (This image from [Wikipedia](https://en.wikipedia.org/wiki/File:IEEE_754_Double_Floating_Point_Format.svg) by Codekaizen is licensed under CC BY-SA 4.0)](./images/IEEE_754_Double_Floating_Point_Format.svg.png)\n\nTo get straight to the point, this can represent up to `2^53 - 1`.\nThe fraction part has 52-bit, plus the exponent part is used to represent 0, so `52 + 1 = 53`.\nFor more details, please refer to the Wikipedia article!\n\n## Check the answer\n\nOkay, let's confirm. `2^53 - 1` is `9007199254740991`.\nIf we add 1 to it, R can still do integer calculation correctly.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 9007199254740991\n\nround(x) - round(x + 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -1\n```\n\n\n:::\n:::\n\n\n\n\nHowever, if we go further, R can no longer detect the difference of 1.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nround(x + 1) - round(x + 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0\n```\n\n\n:::\n:::\n\n\n\n\nSo, this is the limit. Up to `2^53 - 1`, a numeric can safely represent an integer value.\n\nTo be clear, by \"safely\", I don't mean we can treat such an integer-ish numeric just the same as a usual integer. Integer arithmetic and floating-point arithmetic are different. But, still, this is a useful fact especially to those who write C/C++ or Rust-powered R packages.\n\nIn my case of the savvy Rust framework, this means savvy can safely accept integer-ish user input up to `2^53` and convert it to `usize`.\n\n```rust\nuse savvy::{NumericScalar, Sexp, savvy};\n\n#[savvy]\nfn usize_to_string_scalar(x: NumericScalar) -> savvy::Result<Sexp> {\n    let x_usize = x.as_usize()?;\n    x_usize.to_string().try_into()\n}\n```\n\n```r\nusize_to_string_scalar(.Machine$integer.max + 1)\n#> [1] \"2147483648\"\n\n# 2^53 - 1 is okay\nusize_to_string_scalar(9007199254740991)\n#> [1] \"9007199254740991\"\n\n# 2^53 is rejected\nusize_to_string_scalar(9007199254740992)\n#> Error: 9007199254740992.0 is out of range that can be safely converted to usize\n```\n\nSo, is 2^53 large enough? I'm not sure. It depends. You might want to use [the bit64 package](https://cran.r-project.org/web/packages/bit64/index.html) in the end.\nBut, it's a probably good news that we can live without bit64 to some extent.\n\n## Appendix: JavaScript\n\nBy the way, it seems this is the strategy of JavaScript.\nBefore `BigInt`, JavaScript uses that double-precision floating point both for integer number and floating point number.\n\n<https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER>\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}