---
title: "Unofficial Introduction To extendr (2): Type Conversion Between R and Rust"
description: |
  Integrate R and Rust with extendr
author:
  - name: Hiroaki Yutani
    url: {}
date: 06-14-2021
categories:
  - Rust
  - extendr
output:
  distill::distill_article:
    toc: true
    toc_depth: 2
    self_contained: false
creative_commons: CC BY
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}
library(rextendr)
```

[extendr](https://github.com/extendr/extendr) is a project that provides
an interface between R and Rust. In [the last
post](../2021-06-06-unofficial-introduction-to-extendr-1-your-first-r-package-with-rust/),
I explained about how to create an R package with extendr briefly. This
time, we'll walk though how to handle various R types.

## Vector

Let's start with the last example in the last post.

```{extendrsrc add}
#[extendr]
fn add(x: i32, y: i32) -> i32 {
    x + y
}
```

While this works perfectly fine with a single value, this fails when the
length is more than one.

```{r add_error, error=TRUE}
add(1:2, 2:3)
```

This is very easy to fix. In Rust, we can use
[`Vec<T>`](https://doc.rust-lang.org/std/vec/struct.Vec.html) to
represent a vector of values of type `T`.

```{extendrsrc add2}
// I don't explain much about the Rust code this time, but, for now, please don't
// worry if you can't understand what it does at the moment. Probably it's not
// very important to understand this post. Move forward.

#[extendr]
fn add2(x: Vec<i32>, y: Vec<i32>) -> Vec<i32> {
    x.iter().enumerate().map(|(i, x)| x + y[i]).collect()
}
```

```{r add_success}
add2(1:2, 2:3)
```

Easy!

### Wait, didn't you say we can't do this...!?

Some of you might remember, in [this
post](https://yutani.rbind.io/post/some-more-notes-about-using-rust-code-in-r-packages/#passing-a-vector-from-rust-to-r-or-vice-versa),
I wrote

> We cannot simply pass a variable length of vector

from R to Rust.

Yeah, it's true it was too difficult because I was struggling to do it
*via FFI*! There's no metadata available about the length or the
structure of the data by default. But, with extendr, we can seamlessly
access these metadata *via R's C API*. So, there's no difficulties.

## `NA`

One more caveat about `add()` is that this cannot handle a missing
value, `NA`.

```{r add_error2, error=TRUE}
add(1L, NA)
```

In Rust, we can use
[`Option<T>`](https://doc.rust-lang.org/std/option/enum.Option.html) to
represent an optional, or possibly missing, value.

```{// pattern match is one of the most powerful things in Rust, btw!}

{extendrsrc add3}
#[extendr]
fn add3(x: Option<i32>, y: Option<i32>) -> Option<i32> {
    match (x, y) {
        (Some(x), Some(y)) => Some(x + y),
        _ => NA_INTEGER
    }
}
```

This function can handle `NA`.

```{r}
add3(1L, 2L)
add3(1L, NA)
```

It might be safe to always use `Option` since there's always possibility
that R value can be `NA` by nature. But, we might want to choose
non-`Option` version to avoid the overhead (c.f. [How much overhead is
there with Options and Results? - The Rust Programming Language
Forum](https://users.rust-lang.org/t/how-much-overhead-is-there-with-options-and-results/37327)),
so it depends.

## Primitive types

Okay, let's talk about the primitive types at last. Here's the
corresponding table of R types and Rust types.

+-----------+--------+
| R         | Rust   |
+===========+========+
| integer   | i32    |
+-----------+--------+
| numeric   | f64    |
+-----------+--------+
| logical   | bool   |
+-----------+--------+
| character | String |
|           |        |
|           | &str   |
+-----------+--------+
| factor    | \-     |
+-----------+--------+
| complex   | \-     |
+-----------+--------+

: The corresponding types

### Integer and numeric

Integer and numeric can mainly be converted into `i32` and `f64`
respectively. I used "mainly" because they both can be converted into
either of:

- `u8`
- `u16`
- `u32`
- `u64`
- `i8`
- `i16`
- `i32`
- `i64`
- `f32`
- `f64`

