<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Hiroaki Yutani">
<meta name="dcterms.date" content="2023-05-20">

<title>R, Rust, Protect, And Unwinding – Wannabe Rstats-fu</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../assets/favicon.ico" rel="icon">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<meta name="twitter:title" content="R, Rust, Protect, And Unwinding – Wannabe Rstats-fu">
<meta name="twitter:description" content="">
<meta name="twitter:card" content="summary">
</head>

<body class="floating nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Wannabe Rstats-fu</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/yutannihilation"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default toc-left page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">R, Rust, Protect, And Unwinding</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">Rust</div>
                <div class="quarto-category">extendr</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Hiroaki Yutani </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">May 20, 2023</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Contents</h2>
   
  <ul>
  <li><a href="#protect" id="toc-protect" class="nav-link active" data-scroll-target="#protect">Protect</a>
  <ul class="collapse">
  <li><a href="#protect-or-rf_protect" id="toc-protect-or-rf_protect" class="nav-link" data-scroll-target="#protect-or-rf_protect"><code>PROTECT()</code> (or <code>Rf_protect()</code>)</a></li>
  <li><a href="#r_preserveobject" id="toc-r_preserveobject" class="nav-link" data-scroll-target="#r_preserveobject"><code>R_PreserveObject()</code></a></li>
  <li><a href="#get-referenced-by-another-sexp" id="toc-get-referenced-by-another-sexp" class="nav-link" data-scroll-target="#get-referenced-by-another-sexp">Get referenced by another <code>SEXP</code></a></li>
  <li><a href="#when-to-use-which" id="toc-when-to-use-which" class="nav-link" data-scroll-target="#when-to-use-which">When to use which?</a></li>
  </ul></li>
  <li><a href="#unwinding-and-longjmp" id="toc-unwinding-and-longjmp" class="nav-link" data-scroll-target="#unwinding-and-longjmp">Unwinding and <code>longjmp</code></a>
  <ul class="collapse">
  <li><a href="#different-languages-have-different-unwinding-mechanism" id="toc-different-languages-have-different-unwinding-mechanism" class="nav-link" data-scroll-target="#different-languages-have-different-unwinding-mechanism">Different languages have different unwinding mechanism</a></li>
  <li><a href="#r_unwindprotect" id="toc-r_unwindprotect" class="nav-link" data-scroll-target="#r_unwindprotect"><code>R_UnwindProtect()</code></a></li>
  <li><a href="#so-what-about-rust" id="toc-so-what-about-rust" class="nav-link" data-scroll-target="#so-what-about-rust">So, what about Rust?</a></li>
  </ul></li>
  <li><a href="#my-take" id="toc-my-take" class="nav-link" data-scroll-target="#my-take">My take</a></li>
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references">References</a></li>
  </ul>
</nav>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p>In the recent half a year, I’ve been <a href="https://github.com/yutannihilation/unextendr">struggling to understand how the extendr framework works</a>. One of the things I found is that it’s extremely hard to protect and unprotect R objects properly from Rust’s side. Let me share my incomplete knowledges.</p>
<p>(Disclaimer: I’m not an expert around here. My explanations and terms might be inaccurate or incorrect.)</p>
<section id="protect" class="level2">
<h2 class="anchored" data-anchor-id="protect">Protect</h2>
<p>First, let’s talk about how to protect R objects. Protect from what? From the garbage collection (GC) mechanism of R. <a href="https://cran.r-project.org/doc/manuals/r-release/R-exts.html#Garbage-Collection">Writing R Extension</a> (WRE) says:</p>
<blockquote class="blockquote">
<p>The memory allocated for R objects is not freed by the user; instead, the memory is from time to time garbage collected. That is, some or all of the allocated memory not being used is freed or marked as re-usable.</p>
</blockquote>
<p>So, we have to claim the objects we use are in use, otherwise they might be accidentally freed while we are using it, which will causes serious problems. As far as I know, there are mainly 3 ways to do this “protection”.</p>
<section id="protect-or-rf_protect" class="level3">
<h3 class="anchored" data-anchor-id="protect-or-rf_protect"><code>PROTECT()</code> (or <code>Rf_protect()</code>)</h3>
<p>The most basic one is the <code>PROTECT()</code> macro. WRE says:</p>
<blockquote class="blockquote">
<p>If you create an R object in your C code, you must tell R that you are using the object by using the <code>PROTECT</code> macro on a pointer to the object. This tells R that the object is in use so it is not destroyed during garbage collection</p>
</blockquote>
<p><code>PROTECT()</code> takes an <code>SEXP</code> and returns the <code>SEXP</code>, so you can use this like the following example on WRE:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>SEXP ab<span class="op">;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>ab <span class="op">=</span> PROTECT<span class="op">(</span>allocVector<span class="op">(</span>REALSXP<span class="op">,</span> <span class="dv">2</span><span class="op">));</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>REAL<span class="op">(</span>ab<span class="op">)[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="fl">123.45</span><span class="op">;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>REAL<span class="op">(</span>ab<span class="op">)[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="fl">67.89</span><span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>You can also use <code>PROTECT()</code> in a separate line.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>SEXP ab<span class="op">;</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>ab <span class="op">=</span> allocVector<span class="op">(</span>REALSXP<span class="op">,</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>PROTECT<span class="op">(</span>ab<span class="op">);</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>REAL<span class="op">(</span>ab<span class="op">)[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="fl">123.45</span><span class="op">;</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>REAL<span class="op">(</span>ab<span class="op">)[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="fl">67.89</span><span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Wow, super simple. Now that it gets protected, we’ve all done, right? Well, no. You have to remove that <code>PROTECT()</code>ion when it gets no longer needed, otherwise your memory will be exhausted.</p>
<p>This can be done by <code>UNPROTECT()</code>. So, the full function definition would be like this:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>SEXP new_real2<span class="op">()</span> <span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    SEXP ab<span class="op">;</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    ab <span class="op">=</span> PROTECT<span class="op">(</span>allocVector<span class="op">(</span>REALSXP<span class="op">,</span> <span class="dv">2</span><span class="op">));</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    REAL<span class="op">(</span>ab<span class="op">)[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="fl">123.45</span><span class="op">;</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    REAL<span class="op">(</span>ab<span class="op">)[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="fl">67.89</span><span class="op">;</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    UNPROTECT<span class="op">(</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ab<span class="op">;</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Here, you might wonder why <code>UNPROTECT()</code> takes an integer while the corresponding function <code>PROTECT()</code> takes an <code>SEXP</code>. This is because the protection mechanism is stack-based. WRE says:</p>
<blockquote class="blockquote">
<p>The protection mechanism is stack-based, so <code>UNPROTECT(n)</code> unprotects the last <code>n</code> objects which were protected.</p>
</blockquote>
<p><code>UNPROTECT()</code> can unprotect only from the top of the stack. This means you cannot do something like “let’s return an object with protection and unprotect later in another function.” If something gets <code>PROTECT()</code>ed in a function, it’s required to be <code>UNPROTECT()</code> within the function. WRE says:</p>
<blockquote class="blockquote">
<p>Calls to <code>PROTECT</code> and <code>UNPROTECT</code> should balance in each function. A function may only call <code>UNPROTECT</code> or <code>REPROTECT</code> on objects it has itself protected.</p>
</blockquote>
<p>I don’t know well about the design of data structures, but I guess the advantages of being stack-based are</p>
<ul>
<li>fast</li>
<li>can be unwound (WRE says: “Note that the pointer protection stack balance is restored automatically on non-local transfer of control (..snip..) as if a call to <code>UNPROTECT</code> was invoked with the right argument.”)</li>
</ul>
</section>
<section id="r_preserveobject" class="level3">
<h3 class="anchored" data-anchor-id="r_preserveobject"><code>R_PreserveObject()</code></h3>
<p>While the rule of <code>PROTECT()</code> requires as above, we certainly have many valid cases that are not covered by this:</p>
<ol type="1">
<li>We want the object to live among multiple function calls</li>
<li>We want the object to live forever (i.e., until the R session ends)</li>
</ol>
<p>An example of case 1 is to wrap <code>SEXP</code> objects in a C++ class, which should protect in its constructor and unprotect in its destructor (how to call the destructor properly is another headache, but let’s discuss later).</p>
<p>Fortunately, R provides <code>R_PreserveObject()</code> and the corresponding function <code>R_ReleaseObject()</code> for this. WRE says:</p>
<blockquote class="blockquote">
<p>a call to <code>R_PreserveObject</code> adds an object to an internal list of objects not to be collects, and a subsequent call to <code>R_ReleaseObject</code> removes it from that list. This provides a way for objects which are not returned as part of R objects to be protected across calls to compiled code</p>
</blockquote>
<p>So, it sounds like <code>R_PreserveObject()</code> supersedes <code>PROTECT()</code>. Why not use it all the time?? Well, while <code>R_PreserveObject()</code> is great, it’s slow. WRE says:</p>
<blockquote class="blockquote">
<p>It is less efficient than the normal protection mechanism, and should be used sparingly.</p>
</blockquote>
<p>Why slow? This is because how it’s implemented. The explanation in <a href="https://github.com/RcppCore/Rcpp/issues/1081">the related performance issue</a> says:</p>
<blockquote class="blockquote">
<p>This is a simple linked list, so has to be searched linearly to remove objects pushed on early.</p>
</blockquote>
<p>So, are there any efficient ways to provide protection longer than one function call? The answer is simple. To prevent an <code>SEXP</code> from being considered as unused, we can actually use it!</p>
</section>
<section id="get-referenced-by-another-sexp" class="level3">
<h3 class="anchored" data-anchor-id="get-referenced-by-another-sexp">Get referenced by another <code>SEXP</code></h3>
<p>WRE says:</p>
<blockquote class="blockquote">
<p>Protecting an R object automatically protects all the R objects pointed to in the corresponding <code>SEXPREC</code>, for example all elements of a protected list are automatically protected.</p>
</blockquote>
<p>To put this into simpler words, if an R object already belongs to another R object (e.g., an element of a <code>list</code>), it doesn’t need the protection of <code>PROTECT()</code> or <code>R_PreserveObject()</code>. Actually, that’s why functions are supposed to return unprotected results; on the R session, the returned value is immediately assinged to a variable in some environment.</p>
<p>We can utilize this spec in several ways. A straightforward implementation of this is to have one big <code>R_PreserveObject()</code>ed list as the “anchor” and assign R objects to it. extendr uses this way (<a href="https://github.com/extendr/extendr/blob/ca001033e371ff3f52022cea72aa534f2958f041/extendr-api/src/ownership.rs#L60-L61">code</a>). But, if this is done naively, it would also be inefficient as <code>R_ReleaseObject()</code> to search linearly which one to unprotect. So, extendr uses a hashmap nicely. Another reason of hashmap is that extendr allows <code>Clone</code>, so it must track the reference count on Rust’s side as well, but let’s not talk about the details here.</p>
<p>More sophisticated example is cpp11. It uses a doubly-linked-list approach (<a href="https://github.com/r-lib/cpp11/blob/3c877986ce886b320ceafb853358d856f07834f4/inst/include/cpp11/protect.hpp#L431-L433">code</a>), which is based on the suggestion in <a href="https://github.com/RcppCore/Rcpp/issues/1081">the issue</a> above. This is more efficient when unprotecting. The C++ code is a bit advanced, so <a href="https://github.com/yutannihilation/unextendr/blob/master/src/rust/src/protect.rs">my naive implementation in Rust</a> might be a bit easier to read.</p>
</section>
<section id="when-to-use-which" class="level3">
<h3 class="anchored" data-anchor-id="when-to-use-which">When to use which?</h3>
<p>In summary, we have mainly 3 options to protect:</p>
<ol type="1">
<li><code>PROTECT()</code></li>
<li><code>R_PreserveObject()</code></li>
<li>Get refrenced by another <code>SEXP</code></li>
</ol>
<p>You might wonder if we should always use case 3. But, if you look at the implementation of cpp11, it will easily remind you that <code>PROTECT()</code> is needed anyway until the object gets referenced. If you care about efficiency, you should use <code>PROTECT()</code> when it’s enough.</p>
<p>In my understanding, ideally we should</p>
<ol type="1">
<li>Use <code>PROTECT()</code> everywhere as long as the protection is needed within the function</li>
<li>Use <code>R_PreserveObject()</code> for objects that are never released during the R session</li>
<li>Use the doubly-linked list when an object needs protection longer than one function call but shorter than one R session</li>
</ol>
<p>This topic still has more room to discuss, but let’s move on as this is not the main one of this post!</p>
</section>
</section>
<section id="unwinding-and-longjmp" class="level2">
<h2 class="anchored" data-anchor-id="unwinding-and-longjmp">Unwinding and <code>longjmp</code></h2>
<p>What is unwinding? Honestly, I’m not confident what exactly this term refers to, but it seems it’s a cleanup process when some exception happens. For example, <a href="https://en.wikipedia.org/wiki/Call_stack#Unwinding">Wikipedia</a> says:</p>
<blockquote class="blockquote">
<p>Returning from the called function will pop the top frame off the stack, perhaps leaving a return value. The more general act of popping one or more frames off the stack to resume execution elsewhere in the program is called <strong>stack unwinding</strong> and must be performed when non-local control structures are used, such as those used for exception handling.</p>
</blockquote>
<p>Usually, this explanation should be satisfying. But, as I’m talking about Rust, things are a bit more complicated. “non-local control structures” means <code>panic!()</code> to Rust, which we don’t try to catch in usual cases. Yes…, this is the core of the problem I’m writing. Let’s revisit later.</p>
<section id="different-languages-have-different-unwinding-mechanism" class="level3">
<h3 class="anchored" data-anchor-id="different-languages-have-different-unwinding-mechanism">Different languages have different unwinding mechanism</h3>
<p>Let’s forget about Rust. Suppose we want to use C++.</p>
<p>C++ and Rust are the same in that it has difficulty to handle <code>longjmp</code>. C++’s class has destructor, which is called when the object is deleted. So, in theory, a C++ class of a wrapper of an R object can manage the protection with including the unprotecting operation in its destructor.</p>
<p>However, the problem is that, the destructor can be called only in C++’s exception handling. If some R error, which is implemented using <code>longjmp</code>, happens on calling R’s C APIs, the destructor is not called. More details can be found the following blog post by the R core member:</p>
<p><a href="https://blog.r-project.org/2019/03/28/use-of-c-in-packages/index.html">Use of C++ in Packages - The R Blog</a></p>
<blockquote class="blockquote">
<p>Unfortunately, RAII does not work with setjmp/longjmp functions provided by the C runtime for exception handling.</p>
</blockquote>
</section>
<section id="r_unwindprotect" class="level3">
<h3 class="anchored" data-anchor-id="r_unwindprotect"><code>R_UnwindProtect()</code></h3>
<p>Fortunately, R’s C API provides a function for this, <code>R_UnwindProtect()</code>. This is something like <code>tryCatch()</code> at the C-level. The signature is:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>SEXP R_UnwindProtect<span class="op">(</span>SEXP <span class="op">(*</span>fun<span class="op">)(</span><span class="dt">void</span> <span class="op">*</span>data<span class="op">),</span> <span class="dt">void</span> <span class="op">*</span>data<span class="op">,</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>                     <span class="dt">void</span> <span class="op">(*</span>clean<span class="op">)(</span><span class="dt">void</span> <span class="op">*</span>data<span class="op">,</span> Rboolean jump<span class="op">),</span> <span class="dt">void</span> <span class="op">*</span>cdata<span class="op">,</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>                     SEXP cont<span class="op">);</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Basically, this is to wrap <code>fun(data)</code>. If a <code>longjmp</code> error happens during the execution of <code>fun(data)</code>, <code>clean(cdata, TRUE)</code> will be called before actually doing <code>longjmp</code>.</p>
<p>In the C++’s case, it is intended to throw C++ exception in <code>clean()</code> to let C++’s stack unwinding happen first. Then, <code>R_ContinueUnwind(cont)</code> can be used for moving back to C’s (or R’s) exception handling. <code>cont</code> is an R object created by <code>R_MakeUnwindCont()</code>.</p>
<p>For a real example, cpp11’s implemntation is (<a href="https://github.com/r-lib/cpp11/blob/3c36f7f48a4998c0cd0abb2fc964b24393eafe21/inst/include/cpp11/protect.hpp#L90-L115">code</a>):</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>  <span class="at">static</span> SEXP token <span class="op">=</span> <span class="op">[]</span> <span class="op">{</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    SEXP res <span class="op">=</span> R_MakeUnwindCont<span class="op">();</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    R_PreserveObject<span class="op">(</span>res<span class="op">);</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> res<span class="op">;</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">}();</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>jmp_buf jmpbuf<span class="op">;</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>setjmp<span class="op">(</span>jmpbuf<span class="op">))</span> <span class="op">{</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    should_unwind_protect <span class="op">=</span> TRUE<span class="op">;</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">throw</span> unwind_exception<span class="op">(</span>token<span class="op">);</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>  SEXP res <span class="op">=</span> R_UnwindProtect<span class="op">(</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>      <span class="op">[](</span><span class="dt">void</span><span class="op">*</span> data<span class="op">)</span> <span class="op">-&gt;</span> SEXP <span class="op">{</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> callback <span class="op">=</span> <span class="kw">static_cast</span><span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(&amp;</span>code<span class="op">)&gt;(</span>data<span class="op">);</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="kw">static_cast</span><span class="op">&lt;</span>Fun<span class="op">&amp;&amp;&gt;(*</span>callback<span class="op">)();</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>      <span class="op">},</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>      <span class="op">&amp;</span>code<span class="op">,</span></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>      <span class="op">[](</span><span class="dt">void</span><span class="op">*</span> jmpbuf<span class="op">,</span> Rboolean jump<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>jump <span class="op">==</span> TRUE<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>          <span class="co">// We need to first jump back into the C++ stacks because you can't safely</span></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>          <span class="co">// throw exceptions from C stack frames.</span></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>          longjmp<span class="op">(*</span><span class="kw">static_cast</span><span class="op">&lt;</span><span class="bu">std::</span>jmp_buf<span class="op">*&gt;(</span>jmpbuf<span class="op">),</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>      <span class="op">},</span></span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>      <span class="op">&amp;</span>jmpbuf<span class="op">,</span> token<span class="op">);</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Note that this is a bit more complex than what WRE describes. As the comment says, this first jumps into the C++ stack by <code>longjmp()</code>, and throws the C++ exception there (the <code>if</code> branch with <code>setjmp()</code>). The error is caught by a <code>try-catch</code> block like this (a simplefied version of <a href="https://github.com/r-lib/cpp11/blob/3c36f7f48a4998c0cd0abb2fc964b24393eafe21/inst/include/cpp11/declarations.hpp#L32-L52">this original code</a>):</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>SEXP err <span class="op">=</span> R_NilValue</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="cf">try</span> <span class="op">{</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...snip...</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="cf">catch</span> <span class="op">(</span>cpp11<span class="op">::</span>unwind_exception <span class="op">&amp;</span> e<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>  err <span class="op">=</span> e<span class="op">.</span>token</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>  R_ContinueUnwind<span class="op">(</span>err<span class="op">);</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="so-what-about-rust" class="level3">
<h3 class="anchored" data-anchor-id="so-what-about-rust">So, what about Rust?</h3>
<p>Okay, let’s come back to Rust. Rust also has destructor (i.e., <code>Drop</code> trait), so we’ll face the same problem. Can we survive with the same approach as C++?</p>
<p>Yes and no. Rust has a kind of try-catch, <a href="https://doc.rust-lang.org/std/panic/fn.catch_unwind.html"><code>std::panic::catch_unwind()</code></a> while its document says:</p>
<blockquote class="blockquote">
<p>It is not recommended to use this function for a general try/catch mechanism.</p>
</blockquote>
<p>So…, it’s kind of possible. Actually, extendr uses <code>catch_unwind()</code> (<a href="https://github.com/extendr/extendr/blob/ca001033e371ff3f52022cea72aa534f2958f041/extendr-api/src/thread_safety.rs#L105-L148">code</a>). In the code below, the cleanup function <code>do_cleanup()</code> calls <code>panic!()</code>, which is caught by <code>catch_unwind()</code>.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode rust code-with-copy"><code class="sourceCode rust"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> catch_r_error<span class="op">&lt;</span>F<span class="op">&gt;</span>(f<span class="op">:</span> F) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span>SEXP<span class="op">&gt;</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="kw">where</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    F<span class="op">:</span> <span class="bu">FnOnce</span>() <span class="op">-&gt;</span> SEXP <span class="op">+</span> <span class="bu">Copy</span><span class="op">,</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    F<span class="op">:</span> <span class="pp">std::panic::</span><span class="bu">UnwindSafe</span><span class="op">,</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...snip...</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">unsafe</span> <span class="kw">extern</span> <span class="st">"C"</span> <span class="kw">fn</span> do_cleanup(_<span class="op">:</span> <span class="op">*</span><span class="kw">mut</span> <span class="pp">raw::</span><span class="dt">c_void</span><span class="op">,</span> jump<span class="op">:</span> Rboolean) <span class="op">{</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> jump <span class="op">!=</span> <span class="dv">0</span> <span class="op">{</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>            <span class="pp">panic!</span>(<span class="st">"R has thrown an error."</span>)<span class="op">;</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">unsafe</span> <span class="op">{</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> fun_ptr <span class="op">=</span> <span class="pp">do_call::</span><span class="op">&lt;</span>F<span class="op">&gt;</span> <span class="kw">as</span> <span class="op">*</span><span class="kw">const</span> ()<span class="op">;</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> clean_ptr <span class="op">=</span> do_cleanup <span class="kw">as</span> <span class="op">*</span><span class="kw">const</span> ()<span class="op">;</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> x <span class="op">=</span> <span class="cn">false</span><span class="op">;</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> fun <span class="op">=</span> <span class="pp">std::mem::</span>transmute(fun_ptr)<span class="op">;</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> cleanfun <span class="op">=</span> <span class="pp">std::mem::</span>transmute(clean_ptr)<span class="op">;</span></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> data <span class="op">=</span> <span class="pp">std::mem::</span>transmute(<span class="op">&amp;</span>f)<span class="op">;</span></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> cleandata <span class="op">=</span> <span class="pp">std::mem::</span>transmute(<span class="op">&amp;</span>x)<span class="op">;</span></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> cont <span class="op">=</span> R_MakeUnwindCont()<span class="op">;</span></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>        Rf_protect(cont)<span class="op">;</span></span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Note that catch_unwind does not work for 32 bit windows targets.</span></span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> res <span class="op">=</span> <span class="cf">match</span> <span class="pp">std::panic::</span>catch_unwind(<span class="op">||</span> <span class="op">{</span></span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a>            R_UnwindProtect(fun<span class="op">,</span> data<span class="op">,</span> cleanfun<span class="op">,</span> cleandata<span class="op">,</span> cont)</span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span>) <span class="op">{</span></span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true" tabindex="-1"></a>            <span class="cn">Ok</span>(res) <span class="op">=&gt;</span> <span class="cn">Ok</span>(res)<span class="op">,</span></span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true" tabindex="-1"></a>            <span class="cn">Err</span>(_) <span class="op">=&gt;</span> <span class="cn">Err</span>(<span class="st">"Error in protected R code"</span><span class="op">.</span>into())<span class="op">,</span></span>
<span id="cb7-31"><a href="#cb7-31" aria-hidden="true" tabindex="-1"></a>        <span class="op">};</span></span>
<span id="cb7-32"><a href="#cb7-32" aria-hidden="true" tabindex="-1"></a>        Rf_unprotect(<span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb7-33"><a href="#cb7-33" aria-hidden="true" tabindex="-1"></a>        res</span>
<span id="cb7-34"><a href="#cb7-34" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-35"><a href="#cb7-35" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>In general, <code>panic!()</code> should be avoided when the Rust function is called over FFI. <code>panic!()</code> causes unwinding, and cross-language unwinding is considered as undefined behavior (cf., <a href="https://github.com/rust-lang/project-ffi-unwind/blob/master/faq.md">Rust “ffi-unwind” project - FAQ</a>).</p>
<p>However, the problem is, we have to jump. We must escape from the cleanup function. Otherwise, <code>R_ContinueUnwind(cont)</code> will be called (<a href="https://github.com/r-devel/r-svn/blob/e29a22b8faf9c329ad4aafc2a0823666d43d1d84/src/main/context.c#L970-L973">code</a>) automatically.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>    cleanfun<span class="op">(</span>cleandata<span class="op">,</span> jump<span class="op">);</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>jump<span class="op">)</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>        R_ContinueUnwind<span class="op">(</span>cont<span class="op">);</span> </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Rust doesn’t have <code>longjmp</code> / <code>setjmp</code> (<a href="https://github.com/rust-lang/rfcs/issues/2625">rust-lang/rfcs#2625</a>), so the last resort is <code>panic!()</code>. While we know it’s not good, there’s no option left as far as I know.</p>
<p><strong>(Update: <a href="https://yutani.rbind.io/post/dont-panic-we-can-unwind/">I found I was wrong. We can get rid of <code>panic!()</code></a>)</strong></p>
<p>I’m honestly not sure the current extendr’s implementation is really safe, but it seems we anyway need a similar implementation to get things work. (However, I think it’s probably a mistake that it doesn’t call <code>R_ContinueUnwind(cont)</code> to resume the unwinding process on C’s side.)</p>
</section>
</section>
<section id="my-take" class="level2">
<h2 class="anchored" data-anchor-id="my-take">My take</h2>
<p>I’m concluding unwinding cannot be done correctly only with Rust. My take is</p>
<ul>
<li><p>Rust functions should catch all R errors by <code>R_UnwindProtect()</code>.</p></li>
<li><p>Rust functions should not use <code>panic!()</code> and <code>panic_unwind()</code> as a substitute for try-catch, but it seems there’s no other options.</p></li>
<li><p>Rust functions should never call <code>Rf_errorcall()</code> directly. Instead, it should return the error information to the C wrapper function, and accordingly the C function should call <code>Rf_errorcall()</code> (or <code>R_ContinueUnwind()</code>). Note that this is because it’s also possible to throw an error at R-level, but <code>R_ContinueUnwind()</code> is only possible at C-level.</p></li>
</ul>
<p>My work-in-progress implementation using <a href="https://en.wikipedia.org/wiki/Tagged_pointer">tagged pointer</a> can be found here:</p>
<ul>
<li><a href="https://github.com/yutannihilation/unextendr/blob/348e1322fbd881a3300f6de1b94fffb0128634fb/src/rust/src/lib.rs#L39-L83">Rust code</a></li>
<li><a href="https://github.com/yutannihilation/unextendr/blob/348e1322fbd881a3300f6de1b94fffb0128634fb/src/init.c#L9-L12">C code</a></li>
</ul>
</section>
<section id="references" class="level2">
<h2 class="anchored" data-anchor-id="references">References</h2>
<ul>
<li><a href="https://cran.r-project.org/doc/manuals/r-release/R-exts.html#Garbage-Collection">5.9.1 Handling the effects of garbage collection - Writing R Extension</a></li>
<li><a href="https://blog.r-project.org/2019/04/18/common-protect-errors/">Common PROTECT Errors - The R Blog</a></li>
<li><a href="https://doc.rust-lang.org/nomicon/ffi.html#ffi-and-unwinding">The Rustonomicon - FFI and unwinding</a></li>
<li><a href="https://github.com/rust-lang/project-ffi-unwind/blob/master/faq.md">Rust “ffi-unwind” project - FAQ</a></li>
</ul>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/yutani\.rbind\.io");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>